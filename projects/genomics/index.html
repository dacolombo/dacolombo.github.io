<!doctype html><html lang=en><head><title>Genomics Project :: Daniele Colombo</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In this project me and two of my collegues performed a de novo assembly of a chloroplast genome. We run the assembly on a server through the CLI, and then compared the results we obtained using short and long reads."><meta name=keywords content="Bioinformatics,Genomics,Assembly,Mapping,Chloroplast"><meta name=robots content="noodp"><link rel=canonical href=https://www.dacolombo.github.io/projects/genomics/><link rel=stylesheet href=https://www.dacolombo.github.io/assets/style.css><link rel=stylesheet href=https://www.dacolombo.github.io/assets/green.css><link rel=apple-touch-icon href=https://www.dacolombo.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://www.dacolombo.github.io/img/favicon/green.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Genomics Project"><meta property="og:description" content="In this project me and two of my collegues performed a de novo assembly of a chloroplast genome. We run the assembly on a server through the CLI, and then compared the results we obtained using short and long reads."><meta property="og:url" content="https://www.dacolombo.github.io/projects/genomics/"><meta property="og:site_name" content="Daniele Colombo"><meta property="og:image" content="https://www.dacolombo.github.io/genomics/Reference_annotation.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-04-30 10:25:32 +0200 +0200"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Daniele Colombo</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/projects>Projects</a></li><li><a href=/posts>Posts</a></li><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/projects>Projects</a></li><li><a href=/posts>Posts</a></li><li><a href=/about>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.dacolombo.github.io/projects/genomics/>Genomics Project</a></h1><div class=post-meta><span class=post-date>2021-04-30</span></div><span class=post-tags>#<a href=https://www.dacolombo.github.io/tags/bioinformatics/>Bioinformatics</a>&nbsp;
#<a href=https://www.dacolombo.github.io/tags/genomics/>Genomics</a>&nbsp;
#<a href=https://www.dacolombo.github.io/tags/assembly/>Assembly</a>&nbsp;
#<a href=https://www.dacolombo.github.io/tags/mapping/>Mapping</a>&nbsp;
#<a href=https://www.dacolombo.github.io/tags/chloroplast/>Chloroplast</a>&nbsp;</span>
<img src=https://www.dacolombo.github.io/genomics/Reference_annotation.png class=post-cover alt="Genomics Project"><div class=post-content><div><ul><li></li></ul><p>The main topics of this project are:</p><ul><li><a href=https://www.danielecolombo.me/projects/genomics/#data-mining>Data Mining</a></li><li><a href=https://www.danielecolombo.me/projects/genomics/#reads-trimming>Reads trimming</a></li><li><a href=https://www.danielecolombo.me/projects/genomics/#quality-control>Quality control</a></li><li><a href=https://www.danielecolombo.me/projects/genomics/#alignment>Alignment</a><ul><li><a href=https://www.danielecolombo.me/projects/genomics/#alignment-of-illumina-reads-bowtie2>bowtie2</a></li><li><a href=https://www.danielecolombo.me/projects/genomics/#alignment-of-nanopore-reads-minimap2>minimap2</a></li></ul></li><li><a href=https://www.danielecolombo.me/projects/genomics/#the-assembly>Assembly</a><ul><li><a href=https://www.danielecolombo.me/projects/genomics/#abyss>ABySS</a></li><li><a href=https://www.danielecolombo.me/projects/genomics/#canu>Canu</a></li></ul></li><li><a href=https://www.danielecolombo.me/projects/genomics/#annotation>Annotation</a></li></ul><h1 id=evaluation-of-the-differences-in-chloroplast-genome-assembly-using-illumina-and-oxford-nanopore-reads>Evaluation of the differences in chloroplast genome assembly using Illumina and Oxford Nanopore reads<a href=#evaluation-of-the-differences-in-chloroplast-genome-assembly-using-illumina-and-oxford-nanopore-reads class=hanchor arialabel=Anchor>&#8983;</a></h1><p>This is the project that me and two of my collegues had done for the evaluation of the Genomics course. We could access for the first time to a server that the University provided to us in order to do all the computational tasks.<br>The project consisted in performing a chloroplast genome assembly and comparing the differences between results obtained with short and long reads.</p><h1 id=data-mining>Data Mining<a href=#data-mining class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The first thing that we had to do was of course finding the data to work with. In order to do that, we searched in the taxonomy database of <a href=https://www.ncbi.nlm.nih.gov/>NCBI</a>.<br>We also used the <a href=https://pfaf.org/user/Default.aspx>pfaf</a> website (Plants For A Future) to have some inspiration in our search: we looked for plants that had edible and medicinal uses.<br>After some research, we found a good candidate: <a href=https://en.wikipedia.org/wiki/Prunus_mandshurica>Prunus mandshurica</a>. In fact, the Prunus genus included many other species that had their chloroplast genome mapped to use as a reference down the line. The two SRA experiments that we chose for our analysis were:</p><ul><li><a href="https://www.ncbi.nlm.nih.gov/sra/?term=ERR4762302">ERR4762302</a>: obtained with Illumina HiSeq 4000 sequencing.</li><li><a href="https://www.ncbi.nlm.nih.gov/sra/?term=ERR4656976">ERR4656976</a>: obtained with Oxford Nanopore MinION sequencing.</li></ul><p>We then downloaded the fastq files of the runs with <code>fastq-dump</code>:<div class=collapsable-code><input id=571394826 type=checkbox>
<label for=571394826><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
fastq-dump --defline-qual &#34;&#43;&#34; --split-files --gzip --clip ERR4762302
fastq-dump --defline-qual &#34;&#43;&#34; --gzip --clip ERR4656976
</code></pre></div></p><p>Note: after downloading, a folder <code>ncbi/</code> will appear in the working directory. This contains the .SRA files that were used by fastq-dump and can be removed in order to save space (space is very precious on a server where a lot of people will be working).</p><h1 id=reads-trimming>Reads Trimming<a href=#reads-trimming class=hanchor arialabel=Anchor>&#8983;</a></h1><p>When working with Illumina and Oxford Nanopore reads, the first thing to do is to trim them in order to remove the adapters (if present) used during the sequencing.</p><h4 id=illumina-reads-trimming>Illumina Reads Trimming<a href=#illumina-reads-trimming class=hanchor arialabel=Anchor>&#8983;</a></h4><p>To do this for Illumina reads, a FASTA file containing all of the possible adapters is needed. The command to perform the trimming is <a href=https://github.com/ExpressionAnalysis/ea-utils/blob/wiki/FastqMcf.md><code>fastq-mcf</code></a>, and was run with the following options:<div class=collapsable-code><input id=375289416 type=checkbox>
<label for=375289416><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
fastq-mcf -o trimmed.ERR4762302_1.fastq.gz -o trimmed.ERR4762302_2.fastq.gz\
«dir to adapters»/IlluminaAdapters.fasta\
ERR4762302_1.fastq.gz ERR4762302_2.fastq.gz
</code></pre></div>In our case, the output of this command indicated that no adapters were found: this is due to the fact that the reads were already processed before being uploaded to the SRA database. This was also confirmed by the fact that the reads had a length distribution of mean 146 and variance around 15: this indicates that the reads are already trimmed, as Illumina reads are usually of 150 bp strictly.</p><h4 id=nanopore-reads-trimming>Nanopore Reads Trimming<a href=#nanopore-reads-trimming class=hanchor arialabel=Anchor>&#8983;</a></h4><p>For Nanopore reads, the trimming can be performed with the command <a href=https://github.com/rrwick/Porechop><code>porechop</code></a>. This tool searches for the adapters at the ends and in the middle of a sample of the reads: the adapters with the higher mapping percentage are then searched in every read and removed. We run the following command:<div class=collapsable-code><input id=841362975 type=checkbox>
<label for=841362975><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
porechop -i ERR4656976.fastq.gz -o ERR4656976_trimmed.fastq.gz --threads 10
</code></pre></div></p><p>The two original fastq files can then be safely removed as they will no longer be used.</p><h1 id=quality-control>Quality Control<a href=#quality-control class=hanchor arialabel=Anchor>&#8983;</a></h1><p>After downloading and trimming the reads, the first thing was to do some quality checks on the reads that we chose. To do this, <code>fastqc</code> was used. The output of this command is a .html file, that can be visualized in a browser. In particular, to run this command the only argument to pass is the fastq file.<br>For a guide on how to read the output of fastqc, refer to the <a href=https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/>fastqc documentation</a></p><h1 id=alignment>Alignment<a href=#alignment class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The next step of the project was to select the reads that are part of the chloroplast of P. mandshurica. To do that, a reference chloroplast was used. Chloroplasts genomes are usually highly conserved between species of the same genus. That&rsquo;s why we chose as reference some assembled chloroplast genomes of plants belonging to the Prunus genus, in particular:</p><ul><li>P. persica</li><li>P. japonica</li><li>P. mume</li><li>P. avium</li><li>P. dulcis</li></ul><p>To use them in the server we had access to, we had to download the fasta files of these genomes locally, and then upload them through the command line with <code>scp</code>.<br>We then performed the alignment of both Illumina and Nanopore reads (the how will be explained in the following section) for all the refereces, in order to select the reference for which the reads showed the highest coverage.<br>The reads mapped to the references more or less with the same percentage (between 10% and 12%), also resulting in similar coverages. We chose P. persica as our reference because it showed slightly higher numbers.</p><h4 id=alignment-of-illumina-reads-bowtie2>Alignment of Illumina reads: bowtie2<a href=#alignment-of-illumina-reads-bowtie2 class=hanchor arialabel=Anchor>&#8983;</a></h4><p>One of the main tools to align Illumina reads to a reference is <code>bowtie2</code>. For an overview on how to use it, refer to its <a href=https://github.com/BenLangmead/bowtie2>github page</a>.<br>The first thing to do in order to run bowtie2 is creating an index of the reference, which will be stored as a .fai file. This can be done with the <code>bowtie2-build</code> command:<div class=collapsable-code><input id=842597361 type=checkbox>
<label for=842597361><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
bowtie2-build Prunus_persica_chloroplast.fasta persica_CHL
</code></pre></div></p><p>After creating the reference index, the alignment can be performed. As the output of bowtie2 is a .SAM file, which occupies a lot of space, it&rsquo;s suggested to directly convert it into the BAM format. This can be done with <code>samtools</code> (see <a href=https://www.htslib.org/doc/samtools.html>samtools manual</a>). In particular, <code>samtools view</code> was used (by piping the two commands):<div class=collapsable-code><input id=239564781 type=checkbox>
<label for=239564781><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
bowtie2 -x «dir to reference»/persica_CHL -p 10\
	-1 cleaned.ERR4762302_1.fq.gz -2 cleaned.ERR4762302_2.fq.gz\
	| samtools view -@ 10 -b -o ERR4762302.bam -
</code></pre></div></p><p>As a last step, the resulting BAM file can be better used (and stored in a more efficient way) by ordering the reads in it by position. This was done with <code>samtools sort</code>:<div class=collapsable-code><input id=532984176 type=checkbox>
<label for=532984176><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samtools sort -o ERR4762302.sort.bam ERR4762302.bam
</code></pre></div></p><h4 id=alignment-of-nanopore-reads-minimap2>Alignment of Nanopore reads: minimap2<a href=#alignment-of-nanopore-reads-minimap2 class=hanchor arialabel=Anchor>&#8983;</a></h4><p>The tools we decided to use for the alignment of Nanopore reads was <code>minimap2</code>. We referred to its <a href=https://github.com/lh3/minimap2>github readme</a> and its help page to run it. Also in this case, we piped it with the <code>samtools view</code> command in order to convert the SAM output to the BAM format and we then sorted the file by position:<div class=collapsable-code><input id=317569482 type=checkbox>
<label for=317569482><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
minimap2 -t 10 -ax map-ont «dir to reference»/Prunus_persica_chloroplast.fasta\
ERR4656976_trimmed.fastq.gz | samtools view -@ 10 -b -o ERR4656976.bam -;

samtools sort -@ 10 -o ERR4656976.sort.bam ERR4656976.bam;
</code></pre></div></p><h1 id=reads-extraction>Reads Extraction<a href=#reads-extraction class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The mapped reads contained in the BAM file can be extracted with <code>samtools view</code>:<div class=collapsable-code><input id=218954637 type=checkbox>
<label for=218954637><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
#Extract Illumina reads
samtools view -@ 10 -b -F 4 -o ERR4762302_persica_mapped.sort.bam ERR4762302.sort.bam

#Extract Nanopore reads
samtools view -@ 10 -b -F 4 -o ERR4656976_persica_mapped.sort.bam ERR4656976.sort.bam
</code></pre></div>This command will remove all the reads that are unmapped (mapped with the <code>4</code> flag) in the output BAM file.</p><p>After extracting the reads, the mapped reads can be counted with:<div class=collapsable-code><input id=162789543 type=checkbox>
<label for=162789543><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samtools view -@ 10 -c «BAM file»
</code></pre></div></p><p>To perform alignment evaluation and proceed with the assembly in further steps, we extracted the reads in the BAM file into a fastq file.<br>This procedure was carried out with different tools for Illumina and Nanopore reads:</p><ul><li>For Illumina reads, <code>samtools fastq</code> was used:<div class=collapsable-code><input id=653918247 type=checkbox>
<label for=653918247><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samtools fastq -@ 10 -1 ERR4762302_persica_mapped_1.fastq.gz\
	-2 ERR4762302_persica_mapped_2.fastq.gz -c 6\
	-N ERR4762302_persica_mapped.sort.bam
</code></pre></div></li><li>For Nanopore reads, <code>bedtools bamtofastq</code> was used (see <a href=https://bedtools.readthedocs.io/en/latest/content/tools/bamtofastq.html>bamtofastq manual</a>):<div class=collapsable-code><input id=784693251 type=checkbox>
<label for=784693251><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
bedtools bamtofastq -i ERR4656976_persica_mapped.sort.bam\
-fq ERR4656976_persica_mapped.fastq;

gzip ERR4656976_persica_mapped.fastq;
</code></pre></div></li></ul><h1 id=alignment-evaluation-coverage>Alignment Evaluation: Coverage<a href=#alignment-evaluation-coverage class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The main parameter to evaluate the alignment of reads on a reference genome is their coverage.<br>To compute it, we build the reference index with <code>samtools faidx</code> and then we used<code>bedtools genomecov</code> on it (see <a href=https://bedtools.readthedocs.io/en/latest/content/tools/genomecov.html>genomecov manual</a>):<div class=collapsable-code><input id=532196847 type=checkbox>
<label for=532196847><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
#Build the reference index
samtools faidx «dir to reference»/Prunus_persica_chloroplast.fasta

#Compute coverage table for Illumina reads
bedtools genomecov -pc -d -ibam ERR4762302_persica_mapped.sort.bam\
-g «dir to reference»/Prunus_persica_chl.fai &gt; ERR4762302_persica_mapped.covbed.txt

#Compute coverage table for Nanopore reads
bedtools genomecov -d -ibam ERR4656976_persica_mapped.sort.bam\
-g «dir to reference»/Prunus_persica_chl.fai &gt; ERR4656976_persica_mapped.covbed.txt
</code></pre></div></p><p>The <code>.covbed.txt</code> file generated contains three columns:</p><ol><li>The name of the reference sequence</li><li>The position of the base in the reference sequence</li><li>The coverage for that base</li></ol><p>By importing this file in R, it&rsquo;s possible to use the data in the third column to plot the per-base-coverage and to compute its mean:<div class=collapsable-code><input id=325486197 type=checkbox>
<label for=325486197><span class=collapsable-code__language>R</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-R><code>
# Coverage of mapped Illumina reads on P. persica
Covbed_Illumina &lt;- read.delim(&#34;ERR4762302_persica_mapped.covbed.txt&#34;, header=FALSE)
plot(Covbed_Illumina$V3, type=&#34;l&#34;, ylab=&#34;Coverage&#34;, main=&#34;Coverage of Illumina reads&#34;)
mean(Covbed_Illumina$V3)

# Coverage of mapped Nanopore reads on P. persica
Covbed_Nanopore &lt;- read.delim(&#34;ERR4656976_persica_mapped.covbed.txt&#34;, header=FALSE)
plot(Covbed_Nanopore$V3, type=&#34;l&#34;, ylab=&#34;Coverage&#34;, main=&#34;Coverage of Nanopore reads&#34;)
mean(Covbed_Nanopore$V3)
</code></pre></div></p><p>Here are the two resulting plots:</p><p><img src=/genomics/Coverage_illumina.jpeg class=left style=max-width:45%;display:block;float:left;white-space:nowrap;margin-left:15px;margin-right:auto;padding-bottom:15px>
<img src=/genomics/Coverage_nanopore.jpeg class=right style=max-width:45%;display:block;white-space:nowrap;overflow:hidden;margin-left:auto;margin-right:15px;padding-bottom:15px></p><p>We assumed that the coverages were more than sufficient to satisfy the conditions for a good assembly. We also noted that for the Nanopore reads, there were some high-coverage regions, that we hypothesized were repeated regions.<br>We performed a BLAST of the reference to itself, in order to confirm our hypothesis.</p><img src=/genomics/Reference_dotplot.png class=center><p>As can be seen in the resulting dotplot, there are two regions which are inversely repeated. These are exactly positioned in the regions for which the Nanopore reads have an increased coverage. With this we could observe that the reference genome presented Inversed Repeats (IR), which are quite common in chloroplasts regions.<br>The fact that the coverage has high differences in specific regions may induce some problems in the assembly, and needs to be taken into account.</p><h1 id=the-assembly>The assembly<a href=#the-assembly class=hanchor arialabel=Anchor>&#8983;</a></h1><p>The main approaches for sequence assembly are two:</p><ol><li>Overlap Layout Consensus (OLC): this technique is mainly used for low-coverage long reads.</li><li>De Bruijn Graph (DBG): this technique is mainly used for high coverage short reads.</li></ol><p>To see in details the characteristics of these two techniques, you can read this <a href=https://academic.oup.com/bfg/article/11/1/25/191455>article</a>.</p><p>We decided to use these two tools for the assembly:</p><ul><li><a href=https://github.com/bcgsc/abyss><code>ABySS</code></a> to assembly Illumina reads. This tool is based on the DBG algorithm.</li><li><a href=https://canu.readthedocs.io/en/latest/><code>canu</code></a> to assembly Nanopore reads. This tool is based on the OLC algorithm.</li></ul><h4 id=abyss>ABySS<a href=#abyss class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Before running the actual assembly, some steps are required to optimize the parameter of the assembly itself.<br>The first thing to do in order to have the best assembly possible is to find the best <strong>kmer size</strong>. This was done following the <a href=https://github.com/bcgsc/abyss#optimizing-the-parameter-k>ABySS readme</a>:<div class=collapsable-code><input id=876914253 type=checkbox>
<label for=876914253><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
for k in $(seq 17 8 99);
do

mkdir k$k;

abyss-pe -C k$k name=pmandshurica k=$k\
in=&#34;../ERR4762302_persica_mapped_1.fastq.gz ../ERR4762302_persica_mapped_2.fastq.gz&#34;;

done
</code></pre></div></p><p>After this is done, the following commands were run in order to evaluate the goodness of the assembly for each k value:<div class=collapsable-code><input id=271893546 type=checkbox>
<label for=271893546><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
abyss-fac k*/pmandshurica-unitigs.fa
</code></pre></div>It&rsquo;s possible that the command abyss-fac is not found. In that case, you need to specify the ABySS directory in which the program is installed, that should be:<div class=collapsable-code><input id=219483657 type=checkbox>
<label for=219483657><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
/usr/lib/abyss/abyss-fac k*/pmandshurica-unitigs.fa
</code></pre></div></p><p>We obtained the following table as a result:<div class=collapsable-code><input id=275831649 type=checkbox>
<label for=275831649><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
n       n:500   L50     min     N80     N50    N20      E-size  max     sum     name
1276    75      23      500     627     1109   1895     1316    4426    72063   k17/pmandshurica-unitigs.fa
132     37      8       540     2764    5892   9827     6655    17362   130085  k25/pmandshurica-unitigs.fa
36      14      4       1600    8245    13415  18115    14100   25583   131013  k33/pmandshurica-unitigs.fa
16      12      4       1397    10908   14789  18142    15250   24549   131714  k41/pmandshurica-unitigs.fa
14      9       2       1236    15651   24528  51139    30162   51139   131577  k49/pmandshurica-unitigs.fa
10      8       3       1870    15659   19689  40082    24657   40082   131557  k57/pmandshurica-unitigs.fa
7       7       2       1870    19177   35228  40082    28336   40082   131553  k65/pmandshurica-unitigs.fa
11      10      3       1610    9716    18121  40082    23307   40082   131690  k73/pmandshurica-unitigs.fa
11      10      3       1610    9770    18121  40082    23305   40082   131760  k81/pmandshurica-unitigs.fa
13      11      3       1492    9778    18296  40082    23165   40082   131865  k89/pmandshurica-unitigs.fa
14      12      3       515     9786    18304  40083    23047   40083   132724  k97/pmandshurica-unitigs.fa
</code></pre></div>We observed that the best kmer size to use was <code>65</code>, as it led to the lowest number of unitigs.</p><p>After that, the following thing to do was to find the best sample size of reads to use in order to obtain the best assembly. Given the average coverage of ~1200X of all the reads, we decided to perform some sampling in order to obtain the following estimated coverages:</p><ul><li>50X: with a sample of 50.000 reads</li><li>100X: with a sample of 110.000 reads</li><li>200X: with a sample of 220.000 reads</li><li>350X: with a sample of 385.000 reads</li><li>500X: with a sample of 550.000 reads</li><li>750X: with a sample of 820.000 reads</li><li>1000X: with a sample of 1.100.000 reads</li></ul><p>The amount of reads needed to obtain a wanted coverage was computed through the Lander/Waterman equation (the formula can be viewed in <a href=https://www.illumina.com/documents/products/technotes/technote_coverage_calculation.pdf>this document</a>).</p><p>We performed the sampling with <code>seqtk sample</code> (see <a href=https://github.com/lh3/seqtk>seqtk github page</a>):<div class=collapsable-code><input id=628537914 type=checkbox>
<label for=628537914><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samples=(25000 55000 110000 192500 275000 410000 550000);

for size in &#34;${samples[@]}&#34;;
do

seqtk sample -s1000 ERR4762302_persica_mapped_1.fastq.gz ${size} &gt; samples/ERR4762302_$((size/1000))K_1.fastq;
gzip samples/ERR4762302_$((size/1000))K_1.fastq

seqtk sample -s1000 ERR4762302_persica_mapped_2.fastq.gz ${size} &gt; samples/ERR4762302_$((size/1000))K_2.fastq;
gzip samples/ERR4762302_$((size/1000))K_2.fastq;

done
</code></pre></div></p><p>To evaluate which is the best sample size, ABySS was run on all the samples:<div class=collapsable-code><input id=572638419 type=checkbox>
<label for=572638419><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samples=(25000 55000 110000 192500 275000 410000 550000);

for size in &#34;${samples[@]}&#34;;
do

size=$((size/1000))

mkdir ${size}K;
cd ${size}K;

abyss-pe name=&#34;MandshuricaCHL_AbPE_${size}K&#34; k=65\
in=&#34;../samples/ERR4762302_${size}K_1.fastq.gz ../samples/ERR4762302_${size}K_2.fastq.gz&#34;;

cd ..;

done;
</code></pre></div></p><p>To check the best assembly, the command <code>abyss-fac</code> can be run on the <code>scaffolds.fa</code> files as previously shown.<br>We observed that the best assembly was performed with the sample of 820.000 reads (750X coverage), as it was assembled in a single scaffold of <code>131824</code>bp.</p><h4 id=canu>Canu<a href=#canu class=hanchor arialabel=Anchor>&#8983;</a></h4><p>As canu requires lower coverages to perform an assembly, samples of lower sizes were selected by running <code>seqtk sample</code>:<div class=collapsable-code><input id=849135726 type=checkbox>
<label for=849135726><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samples=(5000 10000 20000 30000);

for size in &#34;${samples[@]}&#34;;
do

seqtk sample -s1000 ERR4656976_persica_mapped.fastq.gz ${size} &gt; samples/ERR4656976_$((size/1000))K.fastq;
gzip samples/ERR4656976_$((size/1000))K.fastq

done
</code></pre></div></p><p>Then, we run canu on all the samples with the following comand:<div class=collapsable-code><input id=642318795 type=checkbox>
<label for=642318795><span class=collapsable-code__language>bash</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-bash><code>
samples=(5000 10000 20000 30000);

for size in &#34;${samples[@]}&#34;;
do

size=$((size/1000))

canu -d canu${size}K -p MandshuricaCHL${size} genomeSize=158k\
-nanopore ../samples/ERR4656976_${size}.fastq.gz;

done
</code></pre></div></p><p>We evaluated the best canu assembly with <code>FastaSeqStats</code>, a tool that is part of <a href=https://github.com/aubombarely/GenoToolBox><code>GenoToolBox</code></a>.<br>We observed that the best assembly was performed with the sample of 20.000 reads: this resulted in a single contig of <code>197983</code>bp.</p><h2 id=differences-in-the-assembly>Differences in the assembly<a href=#differences-in-the-assembly class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The two assemblies resulted in quite different sequences in term of length. We thought that this could be due to the presence of repeated sequences or the presence of overlapped sequences in the ends (this is quite frequent with chloroplast genomes, that are circular).<br>The <code>suggestCircular</code> flag in the contigs.fasta file resulting from canu assembly was equal to <code>no</code>, so we thought to BLAST the sequence to itself in order to do further investigations. This was the resulting dotplot:</p><img src=/genomics/Canu_dotplot.png class=center><p>In this image, the presence of Inversed Reapeats (IR) can be observed. These sequences have probably led to problems in the assembly of Nanopore reads.</p><h2 id=annotation>Annotation<a href=#annotation class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The last step was to annotate the assembly, in order to observe the presence of chloroplast genes and evaluate the goodness of the assembly.<br>To do this, the tool <a href=https://chlorobox.mpimp-golm.mpg.de/geseq.html><code>Chlorobox GeSeq</code></a> was used.</p><p>We obtained the following annotations for the two assemblies:</p><p><figure class=center><img src=/genomics/Abyss_annotation.jpeg style=width:75%><figcaption class=center style=width:75%>Annotation of ABySS assembly</figcaption></figure><figure class=center><img src=/genomics/Canu_annotation.jpeg style=width:75%><figcaption class=center style=width:75%>Annotation of Canu assembly</figcaption></figure></p><p>The assembly performed with ABySS shows a similar annotation to the reference chloroplast genome (that you can observe in the cover image of this post), even though the total length of the assembly is lower than the one of the reference.<br>Meanwhile, the assembly performed with canu shows regions repeated two or more times in opposite strands, confirming the presence of multiple IRs in the assembly.</p><h2 id=conclusions>Conclusions<a href=#conclusions class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Even though in general longer reads improve the quality of de novo assembly, in our case it led to problems due to the presence of regions on the reference genome that had an higher local coverage: we identified these regions as Inverted Reapeats (IR). This fact caused Nanopore reads to be assembled in a sequence which is longer and presents multiple IRs.</p></div></div><script src=https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js></script>
<script>addBackToTop({diameter:50,backgroundColor:"rgb(120, 226, 160)",textColor:"#fff"})</script></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://www.dacolombo.github.io/assets/main.js></script>
<script src=https://www.dacolombo.github.io/assets/prism.js></script></div></body></html>