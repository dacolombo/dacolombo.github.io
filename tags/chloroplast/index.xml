<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chloroplast on Daniele Colombo</title><link>/tags/chloroplast/</link><description>Recent content in Chloroplast on Daniele Colombo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 30 Apr 2021 10:25:32 +0200</lastBuildDate><atom:link href="/tags/chloroplast/index.xml" rel="self" type="application/rss+xml"/><item><title>Genomics Project</title><link>/projects/genomics/</link><pubDate>Fri, 30 Apr 2021 10:25:32 +0200</pubDate><guid>/projects/genomics/</guid><description>The main topics of this project are:
Data Mining Reads trimming Quality control Alignment bowtie2 minimap2 Assembly ABySS Canu Annotation Evaluation of the differences in chloroplast genome assembly using Illumina and Oxford Nanopore reads This is the project that me and two of my collegues had done for the evaluation of the Genomics course. We could access for the first time to a server that the University provided to us in order to do all the computational tasks.</description><content>&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>The main topics of this project are:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#data-mining">Data Mining&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#reads-trimming">Reads trimming&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#quality-control">Quality control&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#alignment">Alignment&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#alignment-of-illumina-reads-bowtie2">bowtie2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#alignment-of-nanopore-reads-minimap2">minimap2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#the-assembly">Assembly&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#abyss">ABySS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#canu">Canu&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.danielecolombo.me/projects/genomics/#annotation">Annotation&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="evaluation-of-the-differences-in-chloroplast-genome-assembly-using-illumina-and-oxford-nanopore-reads">Evaluation of the differences in chloroplast genome assembly using Illumina and Oxford Nanopore reads&lt;/h1>
&lt;p>This is the project that me and two of my collegues had done for the evaluation of the Genomics course. We could access for the first time to a server that the University provided to us in order to do all the computational tasks.&lt;br>
The project consisted in performing a chloroplast genome assembly and comparing the differences between results obtained with short and long reads.&lt;/p>
&lt;h1 id="data-mining">Data Mining&lt;/h1>
&lt;p>The first thing that we had to do was of course finding the data to work with. In order to do that, we searched in the taxonomy database of &lt;a href="https://www.ncbi.nlm.nih.gov/">NCBI&lt;/a>.&lt;br>
We also used the &lt;a href="https://pfaf.org/user/Default.aspx">pfaf&lt;/a> website (Plants For A Future) to have some inspiration in our search: we looked for plants that had edible and medicinal uses.&lt;br>
After some research, we found a good candidate: &lt;a href="https://en.wikipedia.org/wiki/Prunus_mandshurica">Prunus mandshurica&lt;/a>. In fact, the Prunus genus included many other species that had their chloroplast genome mapped to use as a reference down the line. The two SRA experiments that we chose for our analysis were:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.ncbi.nlm.nih.gov/sra/?term=ERR4762302">ERR4762302&lt;/a>: obtained with Illumina HiSeq 4000 sequencing.&lt;/li>
&lt;li>&lt;a href="https://www.ncbi.nlm.nih.gov/sra/?term=ERR4656976">ERR4656976&lt;/a>: obtained with Oxford Nanopore MinION sequencing.&lt;/li>
&lt;/ul>
&lt;p>We then downloaded the fastq files of the runs with &lt;code>fastq-dump&lt;/code>:
&lt;div class="collapsable-code">
&lt;input id="584261937" type="checkbox" />
&lt;label for="584261937">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
fastq-dump --defline-qual &amp;#34;&amp;#43;&amp;#34; --split-files --gzip --clip ERR4762302
fastq-dump --defline-qual &amp;#34;&amp;#43;&amp;#34; --gzip --clip ERR4656976
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>Note: after downloading, a folder &lt;code>ncbi/&lt;/code> will appear in the working directory. This contains the .SRA files that were used by fastq-dump and can be removed in order to save space (space is very precious on a server where a lot of people will be working).&lt;/p>
&lt;h1 id="reads-trimming">Reads Trimming&lt;/h1>
&lt;p>When working with Illumina and Oxford Nanopore reads, the first thing to do is to trim them in order to remove the adapters (if present) used during the sequencing.&lt;/p>
&lt;h4 id="illumina-reads-trimming">Illumina Reads Trimming&lt;/h4>
&lt;p>To do this for Illumina reads, a FASTA file containing all of the possible adapters is needed. The command to perform the trimming is &lt;a href="https://github.com/ExpressionAnalysis/ea-utils/blob/wiki/FastqMcf.md">&lt;code>fastq-mcf&lt;/code>&lt;/a>, and was run with the following options:
&lt;div class="collapsable-code">
&lt;input id="614725389" type="checkbox" />
&lt;label for="614725389">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
fastq-mcf -o trimmed.ERR4762302_1.fastq.gz -o trimmed.ERR4762302_2.fastq.gz\
«dir to adapters»/IlluminaAdapters.fasta\
ERR4762302_1.fastq.gz ERR4762302_2.fastq.gz
&lt;/code>&lt;/pre>
&lt;/div>
In our case, the output of this command indicated that no adapters were found: this is due to the fact that the reads were already processed before being uploaded to the SRA database. This was also confirmed by the fact that the reads had a length distribution of mean 146 and variance around 15: this indicates that the reads are already trimmed, as Illumina reads are usually of 150 bp strictly.&lt;/p>
&lt;h4 id="nanopore-reads-trimming">Nanopore Reads Trimming&lt;/h4>
&lt;p>For Nanopore reads, the trimming can be performed with the command &lt;a href="https://github.com/rrwick/Porechop">&lt;code>porechop&lt;/code>&lt;/a>. This tool searches for the adapters at the ends and in the middle of a sample of the reads: the adapters with the higher mapping percentage are then searched in every read and removed. We run the following command:
&lt;div class="collapsable-code">
&lt;input id="463987215" type="checkbox" />
&lt;label for="463987215">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
porechop -i ERR4656976.fastq.gz -o ERR4656976_trimmed.fastq.gz --threads 10
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>The two original fastq files can then be safely removed as they will no longer be used.&lt;/p>
&lt;h1 id="quality-control">Quality Control&lt;/h1>
&lt;p>After downloading and trimming the reads, the first thing was to do some quality checks on the reads that we chose. To do this, &lt;code>fastqc&lt;/code> was used. The output of this command is a .html file, that can be visualized in a browser. In particular, to run this command the only argument to pass is the fastq file.&lt;br>
For a guide on how to read the output of fastqc, refer to the &lt;a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/">fastqc documentation&lt;/a>&lt;/p>
&lt;h1 id="alignment">Alignment&lt;/h1>
&lt;p>The next step of the project was to select the reads that are part of the chloroplast of P. mandshurica. To do that, a reference chloroplast was used. Chloroplasts genomes are usually highly conserved between species of the same genus. That&amp;rsquo;s why we chose as reference some assembled chloroplast genomes of plants belonging to the Prunus genus, in particular:&lt;/p>
&lt;ul>
&lt;li>P. persica&lt;/li>
&lt;li>P. japonica&lt;/li>
&lt;li>P. mume&lt;/li>
&lt;li>P. avium&lt;/li>
&lt;li>P. dulcis&lt;/li>
&lt;/ul>
&lt;p>To use them in the server we had access to, we had to download the fasta files of these genomes locally, and then upload them through the command line with &lt;code>scp&lt;/code>.&lt;br>
We then performed the alignment of both Illumina and Nanopore reads (the how will be explained in the following section) for all the refereces, in order to select the reference for which the reads showed the highest coverage.&lt;br>
The reads mapped to the references more or less with the same percentage (between 10% and 12%), also resulting in similar coverages. We chose P. persica as our reference because it showed slightly higher numbers.&lt;/p>
&lt;h4 id="alignment-of-illumina-reads-bowtie2">Alignment of Illumina reads: bowtie2&lt;/h4>
&lt;p>One of the main tools to align Illumina reads to a reference is &lt;code>bowtie2&lt;/code>. For an overview on how to use it, refer to its &lt;a href="https://github.com/BenLangmead/bowtie2">github page&lt;/a>.&lt;br>
The first thing to do in order to run bowtie2 is creating an index of the reference, which will be stored as a .fai file. This can be done with the &lt;code>bowtie2-build&lt;/code> command:
&lt;div class="collapsable-code">
&lt;input id="168953472" type="checkbox" />
&lt;label for="168953472">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
bowtie2-build Prunus_persica_chloroplast.fasta persica_CHL
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>After creating the reference index, the alignment can be performed. As the output of bowtie2 is a .SAM file, which occupies a lot of space, it&amp;rsquo;s suggested to directly convert it into the BAM format. This can be done with &lt;code>samtools&lt;/code> (see &lt;a href="https://www.htslib.org/doc/samtools.html">samtools manual&lt;/a>). In particular, &lt;code>samtools view&lt;/code> was used (by piping the two commands):
&lt;div class="collapsable-code">
&lt;input id="196754283" type="checkbox" />
&lt;label for="196754283">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
bowtie2 -x «dir to reference»/persica_CHL -p 10\
-1 cleaned.ERR4762302_1.fq.gz -2 cleaned.ERR4762302_2.fq.gz\
| samtools view -@ 10 -b -o ERR4762302.bam -
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>As a last step, the resulting BAM file can be better used (and stored in a more efficient way) by ordering the reads in it by position. This was done with &lt;code>samtools sort&lt;/code>:
&lt;div class="collapsable-code">
&lt;input id="142593876" type="checkbox" />
&lt;label for="142593876">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samtools sort -o ERR4762302.sort.bam ERR4762302.bam
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h4 id="alignment-of-nanopore-reads-minimap2">Alignment of Nanopore reads: minimap2&lt;/h4>
&lt;p>The tools we decided to use for the alignment of Nanopore reads was &lt;code>minimap2&lt;/code>. We referred to its &lt;a href="https://github.com/lh3/minimap2">github readme&lt;/a> and its help page to run it. Also in this case, we piped it with the &lt;code>samtools view&lt;/code> command in order to convert the SAM output to the BAM format and we then sorted the file by position:
&lt;div class="collapsable-code">
&lt;input id="465973281" type="checkbox" />
&lt;label for="465973281">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
minimap2 -t 10 -ax map-ont «dir to reference»/Prunus_persica_chloroplast.fasta\
ERR4656976_trimmed.fastq.gz | samtools view -@ 10 -b -o ERR4656976.bam -;
samtools sort -@ 10 -o ERR4656976.sort.bam ERR4656976.bam;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;h1 id="reads-extraction">Reads Extraction&lt;/h1>
&lt;p>The mapped reads contained in the BAM file can be extracted with &lt;code>samtools view&lt;/code>:
&lt;div class="collapsable-code">
&lt;input id="489635172" type="checkbox" />
&lt;label for="489635172">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
#Extract Illumina reads
samtools view -@ 10 -b -F 4 -o ERR4762302_persica_mapped.sort.bam ERR4762302.sort.bam
#Extract Nanopore reads
samtools view -@ 10 -b -F 4 -o ERR4656976_persica_mapped.sort.bam ERR4656976.sort.bam
&lt;/code>&lt;/pre>
&lt;/div>
This command will remove all the reads that are unmapped (mapped with the &lt;code>4&lt;/code> flag) in the output BAM file.&lt;/p>
&lt;p>After extracting the reads, the mapped reads can be counted with:
&lt;div class="collapsable-code">
&lt;input id="967135824" type="checkbox" />
&lt;label for="967135824">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samtools view -@ 10 -c «BAM file»
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>To perform alignment evaluation and proceed with the assembly in further steps, we extracted the reads in the BAM file into a fastq file.&lt;br>
This procedure was carried out with different tools for Illumina and Nanopore reads:&lt;/p>
&lt;ul>
&lt;li>For Illumina reads, &lt;code>samtools fastq&lt;/code> was used:
&lt;div class="collapsable-code">
&lt;input id="476193258" type="checkbox" />
&lt;label for="476193258">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samtools fastq -@ 10 -1 ERR4762302_persica_mapped_1.fastq.gz\
-2 ERR4762302_persica_mapped_2.fastq.gz -c 6\
-N ERR4762302_persica_mapped.sort.bam
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/li>
&lt;li>For Nanopore reads, &lt;code>bedtools bamtofastq&lt;/code> was used (see &lt;a href="https://bedtools.readthedocs.io/en/latest/content/tools/bamtofastq.html">bamtofastq manual&lt;/a>):
&lt;div class="collapsable-code">
&lt;input id="793426518" type="checkbox" />
&lt;label for="793426518">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
bedtools bamtofastq -i ERR4656976_persica_mapped.sort.bam\
-fq ERR4656976_persica_mapped.fastq;
gzip ERR4656976_persica_mapped.fastq;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;h1 id="alignment-evaluation-coverage">Alignment Evaluation: Coverage&lt;/h1>
&lt;p>The main parameter to evaluate the alignment of reads on a reference genome is their coverage.&lt;br>
To compute it, we build the reference index with &lt;code>samtools faidx&lt;/code> and then we used&lt;code>bedtools genomecov&lt;/code> on it (see &lt;a href="https://bedtools.readthedocs.io/en/latest/content/tools/genomecov.html">genomecov manual&lt;/a>):
&lt;div class="collapsable-code">
&lt;input id="728361459" type="checkbox" />
&lt;label for="728361459">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
#Build the reference index
samtools faidx «dir to reference»/Prunus_persica_chloroplast.fasta
#Compute coverage table for Illumina reads
bedtools genomecov -pc -d -ibam ERR4762302_persica_mapped.sort.bam\
-g «dir to reference»/Prunus_persica_chl.fai &amp;gt; ERR4762302_persica_mapped.covbed.txt
#Compute coverage table for Nanopore reads
bedtools genomecov -d -ibam ERR4656976_persica_mapped.sort.bam\
-g «dir to reference»/Prunus_persica_chl.fai &amp;gt; ERR4656976_persica_mapped.covbed.txt
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>The &lt;code>.covbed.txt&lt;/code> file generated contains three columns:&lt;/p>
&lt;ol>
&lt;li>The name of the reference sequence&lt;/li>
&lt;li>The position of the base in the reference sequence&lt;/li>
&lt;li>The coverage for that base&lt;/li>
&lt;/ol>
&lt;p>By importing this file in R, it&amp;rsquo;s possible to use the data in the third column to plot the per-base-coverage and to compute its mean:
&lt;div class="collapsable-code">
&lt;input id="768542931" type="checkbox" />
&lt;label for="768542931">
&lt;span class="collapsable-code__language">R&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-R" >&lt;code>
# Coverage of mapped Illumina reads on P. persica
Covbed_Illumina &amp;lt;- read.delim(&amp;#34;ERR4762302_persica_mapped.covbed.txt&amp;#34;, header=FALSE)
plot(Covbed_Illumina$V3, type=&amp;#34;l&amp;#34;, ylab=&amp;#34;Coverage&amp;#34;, main=&amp;#34;Coverage of Illumina reads&amp;#34;)
mean(Covbed_Illumina$V3)
# Coverage of mapped Nanopore reads on P. persica
Covbed_Nanopore &amp;lt;- read.delim(&amp;#34;ERR4656976_persica_mapped.covbed.txt&amp;#34;, header=FALSE)
plot(Covbed_Nanopore$V3, type=&amp;#34;l&amp;#34;, ylab=&amp;#34;Coverage&amp;#34;, main=&amp;#34;Coverage of Nanopore reads&amp;#34;)
mean(Covbed_Nanopore$V3)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>Here are the two resulting plots:&lt;/p>
&lt;p>
&lt;img src="/genomics/Coverage_illumina.jpeg" class="left" style="max-width:45%; display:block; float:left; white-space:nowrap; margin-left:15px; margin-right:auto; padding-bottom:15px;" />
&lt;img src="/genomics/Coverage_nanopore.jpeg" class="right" style="max-width:45%; display:block; white-space:nowrap; overflow:hidden; margin-left:auto; margin-right:15px; padding-bottom:15px" />
&lt;/p>
&lt;p>We assumed that the coverages were more than sufficient to satisfy the conditions for a good assembly. We also noted that for the Nanopore reads, there were some high-coverage regions, that we hypothesized were repeated regions.&lt;br>
We performed a BLAST of the reference to itself, in order to confirm our hypothesis.&lt;/p>
&lt;img src="/genomics/Reference_dotplot.png" class="center" />
&lt;p>As can be seen in the resulting dotplot, there are two regions which are inversely repeated. These are exactly positioned in the regions for which the Nanopore reads have an increased coverage. With this we could observe that the reference genome presented Inversed Repeats (IR), which are quite common in chloroplasts regions.&lt;br>
The fact that the coverage has high differences in specific regions may induce some problems in the assembly, and needs to be taken into account.&lt;/p>
&lt;h1 id="the-assembly">The assembly&lt;/h1>
&lt;p>The main approaches for sequence assembly are two:&lt;/p>
&lt;ol>
&lt;li>Overlap Layout Consensus (OLC): this technique is mainly used for low-coverage long reads.&lt;/li>
&lt;li>De Bruijn Graph (DBG): this technique is mainly used for high coverage short reads.&lt;/li>
&lt;/ol>
&lt;p>To see in details the characteristics of these two techniques, you can read this &lt;a href="https://academic.oup.com/bfg/article/11/1/25/191455">article&lt;/a>.&lt;/p>
&lt;p>We decided to use these two tools for the assembly:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bcgsc/abyss">&lt;code>ABySS&lt;/code>&lt;/a> to assembly Illumina reads. This tool is based on the DBG algorithm.&lt;/li>
&lt;li>&lt;a href="https://canu.readthedocs.io/en/latest/">&lt;code>canu&lt;/code>&lt;/a> to assembly Nanopore reads. This tool is based on the OLC algorithm.&lt;/li>
&lt;/ul>
&lt;h4 id="abyss">ABySS&lt;/h4>
&lt;p>Before running the actual assembly, some steps are required to optimize the parameter of the assembly itself.&lt;br>
The first thing to do in order to have the best assembly possible is to find the best &lt;strong>kmer size&lt;/strong>. This was done following the &lt;a href="https://github.com/bcgsc/abyss#optimizing-the-parameter-k">ABySS readme&lt;/a>:
&lt;div class="collapsable-code">
&lt;input id="486193752" type="checkbox" />
&lt;label for="486193752">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
for k in $(seq 17 8 99);
do
mkdir k$k;
abyss-pe -C k$k name=pmandshurica k=$k\
in=&amp;#34;../ERR4762302_persica_mapped_1.fastq.gz ../ERR4762302_persica_mapped_2.fastq.gz&amp;#34;;
done
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>After this is done, the following commands were run in order to evaluate the goodness of the assembly for each k value:
&lt;div class="collapsable-code">
&lt;input id="546723918" type="checkbox" />
&lt;label for="546723918">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
abyss-fac k*/pmandshurica-unitigs.fa
&lt;/code>&lt;/pre>
&lt;/div>
It&amp;rsquo;s possible that the command abyss-fac is not found. In that case, you need to specify the ABySS directory in which the program is installed, that should be:
&lt;div class="collapsable-code">
&lt;input id="631954872" type="checkbox" />
&lt;label for="631954872">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
/usr/lib/abyss/abyss-fac k*/pmandshurica-unitigs.fa
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>We obtained the following table as a result:
&lt;div class="collapsable-code">
&lt;input id="946512378" type="checkbox" />
&lt;label for="946512378">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
n n:500 L50 min N80 N50 N20 E-size max sum name
1276 75 23 500 627 1109 1895 1316 4426 72063 k17/pmandshurica-unitigs.fa
132 37 8 540 2764 5892 9827 6655 17362 130085 k25/pmandshurica-unitigs.fa
36 14 4 1600 8245 13415 18115 14100 25583 131013 k33/pmandshurica-unitigs.fa
16 12 4 1397 10908 14789 18142 15250 24549 131714 k41/pmandshurica-unitigs.fa
14 9 2 1236 15651 24528 51139 30162 51139 131577 k49/pmandshurica-unitigs.fa
10 8 3 1870 15659 19689 40082 24657 40082 131557 k57/pmandshurica-unitigs.fa
7 7 2 1870 19177 35228 40082 28336 40082 131553 k65/pmandshurica-unitigs.fa
11 10 3 1610 9716 18121 40082 23307 40082 131690 k73/pmandshurica-unitigs.fa
11 10 3 1610 9770 18121 40082 23305 40082 131760 k81/pmandshurica-unitigs.fa
13 11 3 1492 9778 18296 40082 23165 40082 131865 k89/pmandshurica-unitigs.fa
14 12 3 515 9786 18304 40083 23047 40083 132724 k97/pmandshurica-unitigs.fa
&lt;/code>&lt;/pre>
&lt;/div>
We observed that the best kmer size to use was &lt;code>65&lt;/code>, as it led to the lowest number of unitigs.&lt;/p>
&lt;p>After that, the following thing to do was to find the best sample size of reads to use in order to obtain the best assembly. Given the average coverage of ~1200X of all the reads, we decided to perform some sampling in order to obtain the following estimated coverages:&lt;/p>
&lt;ul>
&lt;li>50X: with a sample of 50.000 reads&lt;/li>
&lt;li>100X: with a sample of 110.000 reads&lt;/li>
&lt;li>200X: with a sample of 220.000 reads&lt;/li>
&lt;li>350X: with a sample of 385.000 reads&lt;/li>
&lt;li>500X: with a sample of 550.000 reads&lt;/li>
&lt;li>750X: with a sample of 820.000 reads&lt;/li>
&lt;li>1000X: with a sample of 1.100.000 reads&lt;/li>
&lt;/ul>
&lt;p>The amount of reads needed to obtain a wanted coverage was computed through the Lander/Waterman equation (the formula can be viewed in &lt;a href="https://www.illumina.com/documents/products/technotes/technote_coverage_calculation.pdf">this document&lt;/a>).&lt;/p>
&lt;p>We performed the sampling with &lt;code>seqtk sample&lt;/code> (see &lt;a href="https://github.com/lh3/seqtk">seqtk github page&lt;/a>):
&lt;div class="collapsable-code">
&lt;input id="145786239" type="checkbox" />
&lt;label for="145786239">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samples=(25000 55000 110000 192500 275000 410000 550000);
for size in &amp;#34;${samples[@]}&amp;#34;;
do
seqtk sample -s1000 ERR4762302_persica_mapped_1.fastq.gz ${size} &amp;gt; samples/ERR4762302_$((size/1000))K_1.fastq;
gzip samples/ERR4762302_$((size/1000))K_1.fastq
seqtk sample -s1000 ERR4762302_persica_mapped_2.fastq.gz ${size} &amp;gt; samples/ERR4762302_$((size/1000))K_2.fastq;
gzip samples/ERR4762302_$((size/1000))K_2.fastq;
done
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>To evaluate which is the best sample size, ABySS was run on all the samples:
&lt;div class="collapsable-code">
&lt;input id="392714658" type="checkbox" />
&lt;label for="392714658">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samples=(25000 55000 110000 192500 275000 410000 550000);
for size in &amp;#34;${samples[@]}&amp;#34;;
do
size=$((size/1000))
mkdir ${size}K;
cd ${size}K;
abyss-pe name=&amp;#34;MandshuricaCHL_AbPE_${size}K&amp;#34; k=65\
in=&amp;#34;../samples/ERR4762302_${size}K_1.fastq.gz ../samples/ERR4762302_${size}K_2.fastq.gz&amp;#34;;
cd ..;
done;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>To check the best assembly, the command &lt;code>abyss-fac&lt;/code> can be run on the &lt;code>scaffolds.fa&lt;/code> files as previously shown.&lt;br>
We observed that the best assembly was performed with the sample of 820.000 reads (750X coverage), as it was assembled in a single scaffold of &lt;code>131824&lt;/code>bp.&lt;/p>
&lt;h4 id="canu">Canu&lt;/h4>
&lt;p>As canu requires lower coverages to perform an assembly, samples of lower sizes were selected by running &lt;code>seqtk sample&lt;/code>:
&lt;div class="collapsable-code">
&lt;input id="495683271" type="checkbox" />
&lt;label for="495683271">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samples=(5000 10000 20000 30000);
for size in &amp;#34;${samples[@]}&amp;#34;;
do
seqtk sample -s1000 ERR4656976_persica_mapped.fastq.gz ${size} &amp;gt; samples/ERR4656976_$((size/1000))K.fastq;
gzip samples/ERR4656976_$((size/1000))K.fastq
done
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>Then, we run canu on all the samples with the following comand:
&lt;div class="collapsable-code">
&lt;input id="725431869" type="checkbox" />
&lt;label for="725431869">
&lt;span class="collapsable-code__language">bash&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-bash" >&lt;code>
samples=(5000 10000 20000 30000);
for size in &amp;#34;${samples[@]}&amp;#34;;
do
size=$((size/1000))
canu -d canu${size}K -p MandshuricaCHL${size} genomeSize=158k\
-nanopore ../samples/ERR4656976_${size}.fastq.gz;
done
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>We evaluated the best canu assembly with &lt;code>FastaSeqStats&lt;/code>, a tool that is part of &lt;a href="https://github.com/aubombarely/GenoToolBox">&lt;code>GenoToolBox&lt;/code>&lt;/a>.&lt;br>
We observed that the best assembly was performed with the sample of 20.000 reads: this resulted in a single contig of &lt;code>197983&lt;/code>bp.&lt;/p>
&lt;h2 id="differences-in-the-assembly">Differences in the assembly&lt;/h2>
&lt;p>The two assemblies resulted in quite different sequences in term of length. We thought that this could be due to the presence of repeated sequences or the presence of overlapped sequences in the ends (this is quite frequent with chloroplast genomes, that are circular).&lt;br>
The &lt;code>suggestCircular&lt;/code> flag in the contigs.fasta file resulting from canu assembly was equal to &lt;code>no&lt;/code>, so we thought to BLAST the sequence to itself in order to do further investigations. This was the resulting dotplot:&lt;/p>
&lt;img src="/genomics/Canu_dotplot.png" class="center" />
&lt;p>In this image, the presence of Inversed Reapeats (IR) can be observed. These sequences have probably led to problems in the assembly of Nanopore reads.&lt;/p>
&lt;h2 id="annotation">Annotation&lt;/h2>
&lt;p>The last step was to annotate the assembly, in order to observe the presence of chloroplast genes and evaluate the goodness of the assembly.&lt;br>
To do this, the tool &lt;a href="https://chlorobox.mpimp-golm.mpg.de/geseq.html">&lt;code>Chlorobox GeSeq&lt;/code>&lt;/a> was used.&lt;/p>
&lt;p>We obtained the following annotations for the two assemblies:&lt;/p>
&lt;p>
&lt;figure class="center" >
&lt;img src="/genomics/Abyss_annotation.jpeg" style="width:75%;" />
&lt;figcaption class="center" style="width:75%;" >Annotation of ABySS assembly&lt;/figcaption>
&lt;/figure>
&lt;figure class="center" >
&lt;img src="/genomics/Canu_annotation.jpeg" style="width:75%;" />
&lt;figcaption class="center" style="width:75%;" >Annotation of Canu assembly&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>The assembly performed with ABySS shows a similar annotation to the reference chloroplast genome (that you can observe in the cover image of this post), even though the total length of the assembly is lower than the one of the reference.&lt;br>
Meanwhile, the assembly performed with canu shows regions repeated two or more times in opposite strands, confirming the presence of multiple IRs in the assembly.&lt;/p>
&lt;h2 id="conclusions">Conclusions&lt;/h2>
&lt;p>Even though in general longer reads improve the quality of de novo assembly, in our case it led to problems due to the presence of regions on the reference genome that had an higher local coverage: we identified these regions as Inverted Reapeats (IR). This fact caused Nanopore reads to be assembled in a sequence which is longer and presents multiple IRs.&lt;/p></content></item></channel></rss>